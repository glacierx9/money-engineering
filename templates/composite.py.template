#!/usr/bin/env python3
# coding=utf-8
"""
{{NAME}} - Wolverine Tier 2 Composite Strategy

TODO: Add description of portfolio management strategy
"""

import pycaitlyn as pc
import strategyc3 as sc3
import pycaitlynutils3 as pcu3
from typing import List, Dict, Tuple
import math

# Framework configuration
use_raw = True
overwrite = True
granularity = 900
max_workers = 1
worker_no = None
exports = {}
imports = {}
metas = {}
logger = pcu3.vanilla_logger()

# Initialization constant: max cycles needed for warm-up
MAX_BAR_REBUILD = 100  # TODO: Adjust based on your strategy's requirements


class {{NAME}}(sc3.strategy):
    """
    {{NAME}} composite strategy

    Manages multiple basket strategies and allocates capital dynamically.
    TODO: Describe your portfolio management approach
    """

    def __init__(self, initial_money=10000000.00, basket_count=10):
        super().__init__(initial_money)

        # Configuration
        self.basket_count = basket_count

        # Cycle tracking (from sc3.strategy base class)
        # self.timetag - current cycle timestamp (inherited)

        # In-memory only (NOT persisted - for initialization tracking)
        self.bar_since_start = 0  # Cycles since this process started
        self.initialized = False  # Warm-up complete flag

        # Basket management
        self.strategies: List[sc3.strategy] = []
        self.keys: List[Tuple] = []
        self.strategy_map: Dict = {}
        self.available_strategies: Dict = {}
        self.imported_strategies: Dict = {}

        # Portfolio state arrays (one per basket)
        self.markets: List[bytes] = []
        self.codes: List[bytes] = []
        self.metas: List[int] = []
        self.signals: List[int] = []
        self.leverages: List[float] = []
        self.capitals: List[float] = []
        self.pvs: List[float] = []

        # Imported signal storage (updated AFTER _on_cycle_pass)
        self.pending_signals: Dict = {}  # Cache for incoming signals

        # Initialize empty baskets
        self.initialize_empty_baskets()

    def initialize_empty_baskets(self):
        """Initialize basket slots"""
        for i in range(self.basket_count):
            self.keys.append((0, b'', b''))
            basket = sc3.strategy(0.0)
            basket.persistent = False
            self.strategies.append(basket)
        self._save()

    def initialize_imported_strategies(self, imports, metas):
        """Initialize available strategy types from imports"""
        strategies = {}

        for _ns in imports.keys():
            for _name in imports[_ns].keys():
                namespace = pc.namespace_global if _ns == 'global' else pc.namespace_private

                for key in metas.keys():
                    if key[0] == namespace and key[1] == _name:
                        meta_def = metas[key]
                        meta_id = meta_def[5]
                        revision = meta_def[0].get_revision()
                        strategies[(namespace, _name)] = [(namespace, meta_id), (_name, revision)]

        for k in strategies.keys():
            if k[0] == pc.namespace_global and k[1] == 'SampleQuote':
                continue
            self.imported_strategies[strategies[k][0]] = strategies[k][1]

    async def on_bar(self, bar: pc.StructValue) -> pc.StructValue:
        """
        Main signal processing

        CRITICAL TIMING RULES:
        1. Process Tier-1 signals and store them (don't act immediately)
        2. On cycle boundary, process PREVIOUS cycle's signals in _on_cycle_pass()
        3. Update signal storage AFTER _on_cycle_pass() to prevent data leakage
        """
        # Extract metadata
        tm = bar.get_time_tag()  # Milliseconds since epoch
        ns = bar.get_namespace()
        meta_id = bar.get_meta_id()

        # Initialize timetag on first bar
        if self.timetag is None:
            self.timetag = tm

        # Handle cycle boundaries
        if self.timetag < tm:
            # New cycle - process PREVIOUS cycle's signals
            self._on_cycle_pass(tm)

            # Update for next cycle
            self.timetag = tm
            self.bar_since_start += 1

            # Check if initialization complete
            if self.bar_since_start >= MAX_BAR_REBUILD:
                self.initialized = True

        # CRITICAL: Store incoming signals AFTER _on_cycle_pass()
        # This prevents using t+1 signals for cycle t decisions (data leakage)
        if (ns, meta_id) in self.imported_strategies:
            # This is a Tier-1 indicator signal - cache it for NEXT cycle
            signal_key = (bar.get_market(), bar.get_stock_code(), meta_id)
            self.pending_signals[signal_key] = bar
            # TODO: Parse signal fields as needed

        # Synchronize and return state
        self._save()
        self._sync()
        return self.copy_to_sv()

    def _on_cycle_pass(self, time_tag):
        """
        Process cycle - implement basket allocation logic here

        This method processes cycle t using signals collected during cycle t-1.
        All signal updates happen AFTER this method completes.

        Args:
            time_tag: Current cycle timestamp (milliseconds since epoch)
        """
        # TODO: Implement basket management logic using self.pending_signals

        # Example pattern:
        # 1. Process signals from previous cycle
        # for signal_key, signal_bar in self.pending_signals.items():
        #     market, code, meta_id = signal_key
        #     # Parse signal fields
        #     # Determine if allocation needed

        # 2. Allocate new baskets for strong signals
        # if should_allocate:
        #     self._allocate(meta_id, market, code, money, leverage)

        # 3. Deallocate baskets for weak/stopped signals
        # if should_deallocate:
        #     basket.deallocate()

        # 4. Update basket positions
        # for basket in self.strategies:
        #     if basket.allocated:
        #         basket.update_position()

        pass  # Replace with actual logic

    def _save(self):
        """Synchronize arrays with basket states"""
        self.markets = self._get_array('market')
        self.codes = self._get_array('code')
        self.metas = self._get_array('meta_id')
        self.signals = self._get_array('signal')
        self.leverages = self._get_array('leverage')
        self.capitals = self._get_array('pv')
        self.pvs = self._get_array('pv')

    def _get_array(self, prop):
        """Extract property from all baskets"""
        return [getattr(s, prop) for s in self.strategies]

    def _sync(self):
        """Synchronize portfolio metrics"""
        last_pv = self.pv
        self.pv = sum(self.pvs) + self.cash
        self.calc_stats(last_pv)


# Global instance
composite = {{NAME}}()


# Framework callbacks

async def on_init():
    """Initialize composite strategy"""
    global composite, imports, metas, worker_no
    if worker_no == 1 and metas and imports:
        composite.initialize_imported_strategies(imports, metas)
        composite.load_def_from_dict(metas)


async def on_bar(bar: pc.StructValue):
    """Process bars"""
    global composite, worker_no
    if worker_no != 1:
        return None
    return await composite.on_bar(bar)


async def on_ready():
    pass


async def on_market_open(market, tradeday, time_tag, time_string):
    pass


async def on_market_close(market, tradeday, timetag, timestring):
    pass


async def on_reference(market, tradeday, data, timetag, timestring):
    """
    CRITICAL: Forward reference data to composite strategy

    This populates basket.target_instrument for contract rolling.
    Without this, baskets will have empty target_instrument, causing:
    - basket.price = 0
    - basket.pv frozen
    - Trading failures

    See: wos/08-tier2-composite.md Section on on_reference() callback
    """
    global composite, worker_no
    if worker_no == 1:
        composite.on_reference(bytes(market, 'utf-8'), tradeday, data)


async def on_tradeday_begin(market, tradeday, time_tag, time_string):
    pass


async def on_tradeday_end(market, tradeday, timetag, timestring):
    pass
