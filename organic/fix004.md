# Fix 004

Some of critical information is missing from the chapter for stateless. I need you to read this documentation carefully and combine the understanding about the old chapter then reorganize as per the importance the output the chapter again.

## Stateless

### Driver of the frame moving

Let's define the single frame as the StructValue for any specific time of granularity G. As time goes by, the frame will become historical and new frame will be generated.

One root cause of the stateless issue is that we can mistakenly use on_bar for any incoming data to calculate the `latest` frame of sv and push it back to the system as the return value.

The correct way of triggering the calculation for the new frame of data is actually the change of the timetag. ONLY whenever self.timetag moves forward, we should calculate the StructValue of that time. So we have to calculate the new sv only in the _on_cycle_pass event.

### Change of timetag

self.timetag can only be updated by the same latest incoming data of the same granularity. Any bar will be including the information within the range [x,y) where x is the start time and y is the end time while as the definition, self.timetag always equals to y. That is why we cannot use the timetag of incoming sv whose granularity is different from this output indicator.

## Rebuilding

The system has an intrinsic design that for each time of backtesting, it will rewind `rebuild_length` seconds of data to replay. This period is called rebuild or replay for single backtesting run. 

Any indicators generated by the instances of backtesting. So whenever the indicator is restarted, the rebuilding will occur. Theorically, we have to make sure the rebuilding will cover all historical data needed to build reconstruct the state.

During the rebuilding phase, the imported indicators data and the historical outputed data will be pushed to the calculator. So we have to deal with two things:

- restore from the old version of the output indicator(but we have to guarantee they are the same for production)
- reconstruct the states that are not persistently saved

Theorically, if the incoming data is unchanged, we can reconstruct the states exactly the same as the last time of calculation. If our algorithm is the same(like regular way of production), the recalculated output SVs will be the same as last time of running.

## An example

```python
    def _rebuild_finished(self) -> bool:
        """Determine when indicator has enough data in THIS run."""
        WARMUP_BARS = 80 + 10
        return self.bars_since_start >= WARMUP_BARS

    def from_sv(self, sv: pc.StructValue):
        """
        Cache incoming state for reconciliation.
        """
        self.latest_sv = sv

    def _from_sv(self):
        """Restore state during rebuilding phase."""
        if self.latest_sv is not None:
            logger.info(f"Restoring state at bar {self.bar_index}")
            super().from_sv(self.latest_sv)

    def _reconcile_state(self):
        """Compare calculated vs saved state after rebuilding."""
        saved = self._load_from_sv(self.latest_sv)
        assert self._equal(saved), \
            f"Replay consistency violation at bar {self.bar_index}"
    def on_bar(self, _bar):
        """Process bar with replay consistency verification."""
        # Update counters

        ret = []

        tm = _bar.get_time_tag()
        market = _bar.get_market()
        code = _bar.get_stock_code()
        granularity = _bar.get_granularity()
        meta_id = _bar.get_meta_id()

        if granularity == self.granularity and self.timetag is None:
            self.timetag = tm

        if self.granularity == granularity and self.timetag < tm:
            self._on_cycle_pass(tm)
            if self.latest_sv is not None and self.initialized:
                self._reconcile_state()
            if (not self.initialized or not overwrite) and self.latest_sv is not None:
                self._from_sv()
            if self.ready_to_serialize():
                ret.append(self.copy_to_sv())
            # all these below is critical, the only timing for doing this is after calling _on_cycle_pass
            self.latest_sv = None
            self.timetag = tm
            self.bar_index += 1  # Persisted: total bars
            self.bars_since_start += 1  # NOT persisted: bars this run
            self.initialized = self._rebuild_finished()

        self.extractor.on_bar(_bar)
        super().on_bar(_bar)

        if market == self.market and code == self.code and \
                granularity == self.granularity and meta_id == self.meta_id:
            self.from_sv(_bar)

        return ret            
```