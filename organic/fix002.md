# Fix 002

## worker_no


The backtesting framework is designed using the multiple workers mode in parallel. This is a very sophisticated topic, this article will not dive too much deep into this. The simple takeaway is:


- The source code of the indicator could be running in multiple standalone python processes at the same time
- The system will route the SVs of the same key using some dispatching strategy to different calculating process
- worker_no is the global variable used by the calculator source code to identify the number of the parallel processes
- worker_no == 0 means this is the coordinating process(like the reduce process for the map-reduce algorithm), worker 0 will not do actual calculating. It could implement `on_reduce` to receive and process the bars returned by other workers. if the on_reduce is not declared at all, the bars returned by the other workers will be given to the server straightly.
- The framework will be in charge of setting the worker_no for each running processes at run time
- To reference the implementation of the framework, please read :
  - /home/wolverine/bin/running/calculator3.py
  - /home/wolverine/bin/running/calculatorp3.py (in the live environment, this will be called to start all processes from 0 to N-1 respectively, 1 to N-1 will be started by 0 using ssh)
  - /home/wolverine/bin/running/backtest_runner3.py
  - /home/wolverine/bin/running/calculator3_test.py (the entry of starting the backtest processes for dev and test purposes.)

## on_xxx callbacks

### on_reference

#### logic contracts

Future and options as financial derivatives they naturally has different contracts expire intervally. Unlike the share market, stock is intrinsically spot which never has the issue of expiry and contract rolling.

To make the analysis easier, we introduced a mechanism called logic contract. These are all logic contracts, their code ends with `r"<[0-9]{2}>"`. The sematic meaning of the logic contracts are like below:

- <00>: Leading contract. The contract traded of the highest volume of open interest will be mapped to this logic contract.
- <01>: The nearest contract from now to expire
- < N >: The N-th nearest contract from now to expire

Very easy to understand, for different market and commodity, the rules of expiration are different. And the semantics of the logic contract will make the logic contract maps to different real contract at different time.

Usually, this will change daily. So the system will maintain(not the indicator) the map every trading day. For each market, the trading day is defined differently and independently. 

All of the logic contracts and real contracts available along with other assets like(stocks, indices, options) will be maintained every trading day. These data are called Singularity or Reference data. They will be pushed to the indicator before the new trading day begins(usually 10-min before). 

#### on_reference callback

The framework will translate this message into a callback `on_reference`. For the details of on_reference about what will be passed to it, please refer to:

- /home/wolverine/bin/running/calculator3.py

on_reference is very useful for trading strategy, ALL strategies no matter composite or single basket strategies are required to handle this event. 

- /home/wolverine/bin/running/strategyc3.py
- /home/wolverine/bin/running/composite_strategyc3.py

composite_strategy will route the event to the sub strategies accordingly.

### on_market_open and on_market_close

Different market's trading hour is defined as segments of hours of the single trading day. For example:

- DCE's trading day is defined as:

  ```cpp
      // trade_period_map is defined as std::map<std::string, std::vector<std::vector<int>>>
      trade_period_map m = {
          { "trading_period", { { -300, -100 }, { 900, 1015 }, { 1030, 1130 }, { 1330, 1500 } } },
          { "after_weekend", { { -5100, -4900 }, { 900, 1015 }, { 1030, 1130 }, { 1330, 1500 } } },
          { "after_holiday", { { 900, 1015 }, { 1030, 1130 }, { 1330, 1500 } } }
      };
  ```

  - trading_period: this is for the regular trading hours.
    - [-300, -100]: means from 3 hours before the new calendar day of the local time zone to 1 hour before the new calendar day of the local time zone
    - [HHMM, HHMM]: HHMM is the pattern for each element of a single trading period(inclusive for both left and right)
  - after_weekend: is the trading hour for the beginning of the new week.
    - [-5100, -4900]: This means 51 hours before the new week(21:00 on the previous Fri to 23:00 on the previous Fri)
  - after_holiday: means the trading hour specifically after a legal holiday of that market.


The market open/close event will be triggered at the boundries of the trading period. 

Sometimes, tier1 or tier2 strategy will send signal or return calculated value at this moment. Because regularly the calculation will be at the beginning of the new cycle of the bar, so when the market closes at the end of a segment of period the calculation will not trigger. If you want to trigger calculation at those moments, you have to handle the events carefully.

### on_trade_day_begin/end

#### Holidays

For each market, it has the holidays defined for their owns. Holidays are defined as an array of integer[YYYYmmdd]. The date will be in their own local time zone.

#### on_trade_day_begin/end

These two events will be triggered at the beginning of the trade day(10 min before it truly starts) and the end of the trade day accordingly. Similar with the market open/close events, we can return calculated result in those two callbacks.


- For the strategies, the end-of-the-day calculation will be triggered by the end of the trading day.
- For the strategies, the target instrument selection will happen in the on_trade_day_begin.


#### target instrument

Any single basket strategy will only trade one commodity of a market. One problem for that is it has to decide which instrument(contract) should be hold as the exposure. This instrument will be maintained as target_instrument field. Usually this field will not be persistent.

The single basket strategy implements two ways to select the target instruments:

- Select by open interest: means to copy the leading contract from the Singularity of each day(if available)
- Select by trading volume: means to calculate the mostly traded contract of the commodity counted by the class in strategyc3 of that single trading day

#### rolling

Means to switch target instrument from the old value to the new value. Will close the position of the old target and open the position of the new target.

During the rolling, all signals will be blocked until the rolling is done.


### on_init

When the framework is waiting the calculator to get prepared, this event will be triggered. Usually the calculator will fetch meta information not necessarily restricted to from the server in the event.

### on_ready

This is an acknowledge from the server side about the initialization is finished(after on_init).

### on_live


#### Restore

When a live backtest is restarted(for example with the system restarted), the framework will push historical data to help the calculator reconstruct the state. The beginning of the replay will be determined by the argument passed to the calculator3_test.py script for dev environment, or calculator3.py, calculatorp3.py for live env.

After the replay is done, the calculator will enter the state of `live` which means it's ready to receive the live data.


### on_bar

During the backtesting, restoration and live phase. The framework will push the uin/uout to the calculator using this callback.


- Set of import: let's assume the (ns, meta, market, commodity, fields, granularity) is a key to group the imported StructValues:
  - ns: namespace of the meta imported
  - meta: the integer ID of the indicator imported
  - market: the market of the imported SVs, sv.get_market() === market
  - commodity: for the imported SVs, sv.get_stock_code() is either the logical or real contract of that commodity.
  - granularity: sv.get_granularity() == granularity

  The framework will select the legitimate SVs from the server side and push them to the calculator. The timetag for the push batches will increase monotonically for any granularity. And the timetag will be pushed monotonically for all backtest mode(for historical data). But for the real time data, it can only be guaranteed the former condition.

  The range for the SVs to be pushed is defined as the following psuedo code:

  ```python
  
  commodities = {commodity1, 2, 3,}
  ret = []
  for tm in timetags:
    for market in markets:List[bytes]:
        for code in all codes:
            if code is instance of commodities:
                for gra in all granularities:
                    for meta in metas:
                        ret.append(select(tm, gra, market, code, meta)[:fields])
   return ret
  ```

#### bar routing

There are 3 patterns for implementing a calculator:

- use <00>: to output the instance of single frame sv using specific market/commodity<00>, it's typical for implementing indicator for each commodities.
- use real contract code: this is typical for implementing resampler like ZampleQuote for each real or logic contract
- use C<00> where C is a placeholder as a constant. This is usually some aggregation for calculating index like target. For example we can use rb<00> to hold the black mineral price index indicator.

It's always the good practice to use single instance of sv_object to calculate a target of specific (market, code, granularity). 

Usually for the on_bar, we will implement some mechanism for routing the bar to the object of sv_object relying on the bar. For the most cases, <00> type of indicators will rely only on the commodity it's outputting(unless this commodity used for outputting is only a placeholder). real contract type of indicator will rely on the exact (market, code) for the incoming bar.

